syntax = "proto3";
package ir.uid.service;
option java_multiple_files = true;
option java_package = "ir.uid.service";

import "validate/validate.proto";
import "google/api/annotations.proto";
import "ir/uid/base/base.proto";
import "ir/uid/base/auth.proto";
import "ir/uid/base/deviceinfo.proto";
import "ir/uid/external/base/user.proto";

/*
 * Session Service is responsible for managing session basic authentication information
 * for clients and apps. KeyEchange, CheckChallege, RegisterApp, RegisterUserSession are
 * the endpoints that are exposed with SessionService.
 */
service SessionService {
  /*
   * KeyExchange is used to create a shared secret between client and the server for
   * the duration of the session. Sensitive data is encrypted using the shared secret
   * generated during this process.
   * to ensure correct generation of shared secret, immediately after this endpoint,
   * CheckChallenge endpoint is called.
   */
  rpc KeyExchange(SessionKeyExchangeRequest) returns (SessionKeyExchangeResponse) {
    option (google.api.http) = {
      post: "/session/key-exchange"
      body: "*"
    };
  };
  /*
   * This Endpoint is used to Ensure correctness of generated shared secret during KeyExchange
   * Decrypted challenge which is given to the client in KeyExchange is passed to the server in
   * this endpoint, if successful, step token for Register User session is given to client.
   */
  rpc CheckChallenge(ChallengeRequest) returns (ChallengeResponse) {
    option (google.api.http) = {
      post: "/session/challenge"
      body: "*"
    };
  };
  /*
   * This is used internally by the UID SDK to register apps that have integrated UID
   * SKD.
   */
  rpc RegisterApp(RegisterAppRequest) returns (RegisterAppResponse) {
    option (google.api.http) = {
      post: "/session/register-app"
      body: "*"
    };
  };
  /*
   * RegisterUserSession is used to start a user authentication session, initial user information
   * alongside business and app information is passed to this endpoint, and if successful a user-session
   * is generated for the user.
   */
  rpc RegisterUserSession(RegisterUserSessionRequest) returns (RegisterUserSessionResponse) {
    option (google.api.http) = {
      post: "/session/user-session"
      body: "*"
    };
  };
}




message RegisterUserSessionRequest{
  ir.uid.base.RequestContext context = 1 [(validate.rules).message.required = true];
  ir.uid.base.User user = 2;
}

message RegisterUserSessionResponse{
  ir.uid.base.ResponseContext context = 1 [(validate.rules).message.required = true];
}

/*
 * This request is only meant to be sent once the host app is ready to be lunched.
 * Using this request host app and it's signature will be whitelisted in UID backend
 */
message RegisterAppRequest {
  ir.uid.base.RequestContext context = 1 [(validate.rules).message.required = true];
  //registration token that is acquired offline from UID office to register host app before lunch
  string appRegistrationToken=2 [(validate.rules).message.required = true];
  // A hash generated by UID SKD to identify host app combination with UID SDK
  bytes appSelfCheckHash = 3 [(validate.rules).message.required = true];
}

/*
 * Server response to RegisterAppRequest
 */
message RegisterAppResponse {
  ir.uid.base.RequestContext context = 1 [(validate.rules).message.required = true];
}

/*
 *
 */
message ChallengeRequest{
  ir.uid.base.RequestContext context = 1 [(validate.rules).message.required = true];
  // Decrypted challenge that is received from keyExchange response
  bytes challengeResponse = 2;
}

message ChallengeResponse{
  ir.uid.base.ResponseContext context = 1 [(validate.rules).message.required = true];
}


/* contains device information that UID sdk is running on */
message DeviceOriginInformation{
  /* device id that is collected from host OS */
  bytes deviceId = 1 [(validate.rules).bytes = {min_len: 8, max_len: 32}];
  /* detail device information and capabilities */
  ir.uid.base.Device device = 5;
}


/*
 * this request is used to generate shared secret between client and server
 */
message SessionKeyExchangeRequest {
  // **REQUIRED** Session and application associated data.
  ir.uid.base.RequestContext context = 1 [(validate.rules).message.required = true];


  /*
   * **REQUIRED** Ephemeral P-384 (secp384r1) public key generated by device encoded using ASN.1 in binary (DER) format.
   * This key will be be used for Diffie-Hellman key exchange (ECDH) on server and client.
   */
  bytes publicKey = 3 [(validate.rules).bytes.len = 120];



  // Cipher algorithm for encrypting passwords.
  ir.uid.base.CipherMethod cipher_method = 4 [(validate.rules).enum = {not_in: [0]}];
//  ir.uid.base.Device device = 5;
}


/*
 * Server response to key exchange which provided it's public key with a challenge
 * that will be used in CheckChallenge endpoint.
 */
message SessionKeyExchangeResponse {
  // **REQUIRED** Status and response associated data.
  ir.uid.base.ResponseContext context = 1 [(validate.rules).message.required = true];
  /*
   * P-384 (secp384r1) Ephemeral public key generated by server encoded using ASN.1 in binary (DER) format.
   * This key will be be used for Diffie-Hellman key exchange (ECDH) on server and client
   */
  bytes publicKey = 3 [(validate.rules).message.required = true];
  /*
   * encrypted challenge token which is used in CheckChallenge endpoint to ensure validity of
   * session shared secret
   */
  bytes challengeToken = 4 [(validate.rules).message.required = true];
}






